# Dust System Patterns

## Core Framework Architecture

- **WASM Runtime:** Dart runtime compiled to WebAssembly (WASM) via
  `dart compile wasm`.
- **Component Model:**
  - UI built by composing `Component` instances (`StatelessWidget`,
    `StatefulWidget`), potentially with `Key`s.
  - `StatefulWidget` uses a `State` object for mutable state and UI building.
  - `State` has lifecycle methods (`initState`, `didUpdateWidget`, `build`,
    `dispose`, etc.), a `setState` method (which calls `_markNeedsBuild`), and a
    `context` property (a basic `BuildContext`). `_markNeedsBuild` triggers an
    update via the `_updateRequester` callback provided by the renderer.
  - `Component`s are represented in the VNode tree by `VNode` instances created
    with `VNode.component()`. These VNodes store the `Component` instance, its
    `key`, the associated `State` object (for StatefulWidgets, managed by the
    renderer), and the `VNode` tree rendered by the component (`renderedVNode`).
  - `State.build()` and `StatelessWidget.build()` return a `VNode` tree
    representing the component's internal structure.
  - HTML helper functions (`html.dart`) now accept `Component` instances as
    children and create `VNode.component` nodes.
- **Declarative Rendering Engine (Keyed Diffing):**
  - Developers declare UI in `build()` methods, ideally using HTML helper
    functions (e.g., `div()`, `h1()`) which return a `VNode` tree.
  - **Initial Render:** Handles `StatefulWidget` creation and initial `build`
    via `_patch` (with `oldVNode` as null).
  - **Update Mechanism (Keyed Diffing & setState):**
    - **Component Update (Parent Rebuild):** When a parent component rebuilds,
      `_patch` might call `_updateComponent`. `_updateComponent` reuses the
      existing `State` (if applicable), calls `frameworkUpdateWidget`
      (triggering `didUpdateWidget`), then calls `build` and recursively patches
      the new rendered tree against the old one.
    - **Internal State Update (`setState`):** `State.setState` calls
      `_markNeedsBuild`, which invokes the `_updateRequester` callback set
      during `_mountComponent`. This callback now contains logic to get the
      parent DOM node, call `build` on the state, and call `_patch` to diff the
      new rendered tree against the previously rendered tree (`renderedVNode`
      stored on the component's VNode).
  - **Patching (`_patch`):**
    - **Differentiates Node Types:** First checks if the new/old VNodes
      represent Components (`VNode.component != null`).
    - **Component Lifecycle:** If dealing with components, calls helper
      functions (`_mountComponent`, `_updateComponent`, `_unmountComponent`) to
      manage their lifecycle.
    - **Element/Text Patching:** If dealing with element or text nodes, compares
      types/tags. If same, updates attributes, listeners (using `jsFunctionRefs`
      for removal), and text content. Delegates child patching to
      `_patchChildren`. If different, unmounts the old node (calling
      `removeVNode` which handles recursive listener cleanup) and mounts the new
      node (`_createDomElement`).
    - `VNode.domNode` links VNodes to their corresponding DOM nodes.
  - **Child Patching (`_patchChildren`):** Implements a keyed reconciliation
    algorithm. Recursively calls `_patch` for matching children. Calls
    `removeVNode` (now a top-level helper) for removed children and
    `_createDomElement` or `_mountComponent` (via `_patch`) for added children.
- **State Management:**
  - Basic component state managed via `State` and `setState`.
  - **Riverpod Integration (Basic):**
    - `runApp` creates a root `ProviderContainer` and a root `BuildContext`
      containing it.
    - The `BuildContext` is passed down the component tree by the renderer.
    - `Consumer` widget (`packages/component/lib/consumer.dart`) accesses the
      `ProviderContainer` via `context.container`.
    - `Consumer` uses a `WidgetRef` to interact with the container and trigger
      rebuilds on its own `State` via `setState`.
  - Framework-level context/DI patterns (replacing global container) are future
    goals.
- **Routing:** (Not yet implemented) Goal is a client-side SPA router.
- **JavaScript Bridge:**
  - **WASM Loading:** Handled by the JS loader generated by `build_runner`
    (`web/main.dart.js`), which imports functions from the compiled WASM module
    (`web/main.wasm`) and its JS bridge (`web/main.mjs`).
  - **Dart <-> JS Communication:** Uses `dart:js_interop`. Dart calls JS
    functions (defined via `@JS`) for DOM manipulation and browser APIs (like
    `addEventListener`). JS calls exported Dart functions (e.g., `$invokeMain`).
  - **DOM Access & Event Handling:** Renderer (`_createDomElement`, `_patch`)
    now uses the `dust_dom` abstraction layer (`DomNode`, `DomElement`
    extensions) for DOM manipulation (e.g., `appendChild`, `removeChild`,
    `setAttribute`, `addEventListener`). Direct JS interop calls have been
    removed from the renderer core logic. Dart event callbacks are still wrapped
    in a JS function passing `DomEvent` and converted using `.toJS` before being
    passed to `dust_dom`'s `addEventListener`.
- **Application Entry Point:**
  - `web/index.html` loads the `build_runner` generated `web/main.dart.js` as a
    module.
  - `web/main.dart.js` handles WASM loading and calls the exported `$invokeMain`
    function.
  - `$invokeMain` executes the Dart `main()` function in `web/main.dart`.
  - User's Dart `main()` calls the framework's `runApp` function (defined in
    `dust_renderer`) to mount the root component.
- **Sandboxing:** Execution remains within the browser's WASM sandbox.

## Key Technical Decisions (Framework Context)

- **Rendering Strategy:** Implemented a keyed Virtual DOM diffing/patching
  strategy (`_patch` delegating to `_patchChildren`). Further optimization is
  possible.
- **Component API Design:** Current class-based approach is similar to Flutter.
  `build()` return type is `VNode`. Developers are encouraged to use HTML helper
  functions (`package:dust_component/html.dart`) for better readability. `VNode`
  includes `key`, `listeners` (using `DomEvent`), and `jsFunctionRefs`. Further
  refinement needed for props and context.
- **State Management Approach:** Basic Riverpod integration implemented.
  `ProviderContainer` is created at the root (`runApp`) and passed down via a
  simple `BuildContext` object, which is accessible within `State` objects
  (`state.context`). `Consumer` widget uses this context to get the container.
  This avoids global variables but still relies on a custom `Consumer`
  implementation. Aligning closer to Flutter's `ConsumerWidget` pattern
  (requiring a more complex `BuildContext` and rendering integration) is a
  future goal.
- **JS/WASM Bridge Implementation:** Using `dart:js_interop`. Renderer now uses
  the `dust_dom` abstraction layer instead of direct JS interop calls for DOM
  manipulation. Event listener callbacks still use `.toJS` on a wrapper
  function.
- **Build Tooling Integration:** How to integrate for hot reload and production
  builds?

## Core Patterns

- **Declarative UI Helpers Pattern:** Providing functions (`div`, `h1`, etc.)
  that mirror HTML tags to simplify `VNode` creation in `build` methods.

- **Component Pattern:** Core UI building block.
- **State Management Pattern:** Using `State` for local state. Riverpod
  integration provides `Provider`s for app state, accessed via `Consumer` widget
  (which gets the `ProviderContainer` from its `BuildContext`) and `WidgetRef`.
- **Context Pattern (Basic):** A simple `BuildContext` object is created by the
  renderer and passed down to `State` objects, primarily carrying the
  `ProviderContainer`.
- **Observer Pattern:** Implicitly used via `StreamProvider` and `setState`
  triggering updates.
- **Callback Pattern:** Used for `State` (`_updateRequester`) to request updates
  from the renderer when `setState` is called. The renderer provides this
  callback during component mounting.
- **Facade Pattern:** Implemented via `dust_dom` package, providing a Dart API
  over JS DOM objects using `@staticInterop`.
- **Bootstrap Pattern:** `build_runner` generates the necessary JS bootstrap
  code (`web/main.dart.js`) to load and initialize the WASM application.
- **Application Runner Pattern:** Framework provides a simple `runApp` function
  as the public entry point for users.
- **Virtual DOM Node Pattern:** Using `VNode` objects to represent the desired
  structure.
  - `VNode.element`: Represents HTML elements (tag, attributes, children,
    listeners, key, domNode, jsFunctionRefs).
  - `VNode.text`: Represents text content (text, domNode).
  - `VNode.component`: Represents a `Component` instance (component, key, state,
    renderedVNode, domNode - linking to the root DOM node of the rendered
    output).
- **Diffing/Patching Pattern:** Comparing VNode trees (`_patch`). Differentiates
  between component nodes and element/text nodes. Uses helper functions
  (`_mountComponent`, `_updateComponent`, `_unmountComponent`) for component
  lifecycle. Uses keyed reconciliation (`_patchChildren`) for child lists.
- **Event Listener Management Pattern:**
  - **Creation/Update:** Wrapping Dart callbacks `(DomEvent event) => ...` in a
    JS function `(JSAny jsEvent) { dartCallback(DomEvent(jsEvent)); }`,
    converting the wrapper using `.toJS`, storing the `JSFunction` reference on
    the `VNode` (`jsFunctionRefs`), and using these references in `_patch` to
    add/remove listeners during updates. Listener update logic in `_patch`
    simplified (always remove/add).
  - **Removal:** When a DOM node is removed during patching (`_patchChildren` ->
    `removeVNode`), the framework now **recursively** traverses the
    corresponding VNode and its children, using the stored `jsFunctionRefs` to
    explicitly call `removeEventListener` for all associated listeners before
    the DOM node is detached. This ensures proper cleanup.
- **Atomic CSS Generation Pattern (Build-Time):**
  - A `build_runner` Builder (`AtomicStyleBuilder` in `dust_atomic_styles`
    package) scans Dart source files (`lib/**`, `web/**`).
  - It uses `analyzer` to parse the AST and find HTML helper function calls
    (e.g., `div`, `button`).
  - It extracts string literals from the `class` key within the `attributes` map
    argument.
  - Extracted class names are split and collected into a set (`_allClassNames`).
  - Predefined rules (`atomicRules` map with Regex and generator functions) are
    used to convert recognized atomic class names into CSS rules
    (`generateAtomicCss`).
  - The generated CSS rules are written to a temporary file
    (`.atomic_styles.css.temp`) during the build process (current implementation
    writes cumulative CSS per input, needs refinement for aggregation).
  - The final aggregated CSS file (e.g., `web/atomic_styles.css`) is linked in
    `web/index.html`.

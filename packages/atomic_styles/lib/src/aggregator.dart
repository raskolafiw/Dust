import 'dart:async';
import 'package:build/build.dart';
import 'package:glob/glob.dart';

import 'rules.dart'; // Import the rules and generator

/// A PostProcessBuilder that aggregates atomic class names from .classes files
/// and generates the final atomic CSS file.
class AtomicCssAggregator implements PostProcessBuilder {
  @override
  final inputExtensions = ['.classes']; // Reads the .classes files

  // This builder doesn't generate per-module outputs, it generates one aggregate file.
  // The actual output path is controlled by the build.yaml configuration for the $package$ target.
  // We don't declare outputExtensions here for that reason.

  @override
  Future<void> build(PostProcessBuildStep buildStep) async {
    final allFoundClasses = <String>{};

    // Find and read all .classes files generated by the previous builder phase.
    // Use findAssets from the buildStep (available via PostProcessBuildStep)
    final classesFiles = buildStep.findAssets(Glob('**/*.classes'));

    await for (final inputId in classesFiles) {
      // Check if we can actually read the asset
      if (!await buildStep.canRead(inputId)) continue;

      // Use readInputAsString (correct method for PostProcessBuildStep)
      final content = await buildStep.readInputAsString(inputId);
      final classesInFile =
          content.split('\n').where((line) => line.trim().isNotEmpty);
      allFoundClasses.addAll(classesInFile);
      // Delete the intermediate .classes file after reading
      await buildStep.deletePrimaryInput(); // Deletes the inputId asset
    }

    if (allFoundClasses.isEmpty) {
      log.info(
          'AtomicCssAggregator: No atomic classes found in any temp file.');
      // Optionally delete the output file if it exists? Or write an empty file?
      // Let's write an empty file for consistency.
      final outputId =
          AssetId(buildStep.inputId.package, 'web/atomic_styles.css');
      await buildStep.writeAsString(
          outputId, '/* No atomic styles generated */');
      return;
    }

    // Regenerate CSS based on the *unique* set of found classes
    // This ensures consistency and applies rules correctly even if temp files had partial info.
    final finalCssMap = generateAtomicCss(allFoundClasses);

    // Generate the final CSS output string
    final cssOutputBuffer = StringBuffer();
    cssOutputBuffer.writeln('/* Generated by Dust AtomicCssAggregator */');
    cssOutputBuffer
        .writeln('/* Found ${allFoundClasses.length} unique atomic classes */');

    final sortedClassNames = finalCssMap.keys.toList()..sort();
    for (final className in sortedClassNames) {
      final escapedClassName = className.replaceAllMapped(
          RegExp(r'[.:/\]'), (match) => '\\${match.group(0)}');
      cssOutputBuffer.writeln('.$escapedClassName {');
      cssOutputBuffer.writeln('  ${finalCssMap[className]}');
      cssOutputBuffer.writeln('}');
    }

    // Define the final output asset ID
    final outputId =
        AssetId(buildStep.inputId.package, 'web/atomic_styles.css');

    // Write the final aggregated CSS file
    await buildStep.writeAsString(outputId, cssOutputBuffer.toString());
    log.info(
        'AtomicCssAggregator: Wrote final aggregated CSS to ${outputId.path}');

    // Delete the temporary input files (optional, but good practice)
    // Note: Deleting inputs within a PostProcessBuilder might have side effects
    // in watch mode. Let's skip deletion for now.
    // await for (final inputId in tempFiles) {
    //   await buildStep.deletePrimaryInput(inputId);
    // }
  }
}

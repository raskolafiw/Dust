import 'dart:async';
import 'package:build/build.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/analysis/utilities.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/ast/visitor.dart';

import 'rules.dart'; // Import the rules and generator

class AtomicStyleBuilder implements Builder {
  @override
  final buildExtensions = const {
    // We don't generate per-input file, but rather an aggregate file.
    // This builder will run on all Dart files but output a single CSS file.
    // The output target is defined in build.yaml.
    '.dart': [
      '.atomic_styles.css.temp'
    ] // Temporary extension, real output in build.yaml
  };

  // Store collected class names across all analyzed files
  final Set<String> _allClassNames = {};

  @override
  Future<void> build(BuildStep buildStep) async {
    // Reset for each build run (important for watch mode)
    // Note: This simple reset might not be fully robust in complex build scenarios.
    // A more robust approach might involve tracking dependencies differently.
    if (buildStep.inputId.path.endsWith('.dart')) {
      // Only process dart files
      // A better approach might be needed if the build runner triggers this per file
      // in a way that makes aggregation difficult. Let's start simple.
      // If this runs for the first dart file, clear the set.
      // This is a HACK for now. A proper aggregate builder is complex.
      if (_allClassNames.isEmpty) {
        // Very basic reset detection
        print(
            "AtomicStyleBuilder: Resetting collected classes for new build run.");
      }
    } else {
      return; // Skip non-dart files
    }

    final inputId = buildStep.inputId;
    final content = await buildStep.readAsString(inputId);

    try {
      final parseResult =
          parseString(content: content, throwIfDiagnostics: false);
      if (parseResult.errors.isNotEmpty) {
        log.warning(
            'Skipping ${inputId.path} due to parsing errors: ${parseResult.errors}');
        return;
      }

      final visitor = _ClassNameVisitor();
      parseResult.unit.accept(visitor);
      _allClassNames.addAll(visitor.foundClassNames);

      // We generate the final CSS file based on ALL collected classes at the end.
      // How to trigger this final step? build_runner usually works per input.
      // A common pattern is to have a specific input act as a trigger,
      // or use a PostProcessBuilder.

      // For now, let's write the *cumulative* CSS to a temp file for each Dart file processed.
      // The final output will be defined in build.yaml using a build_to: cache strategy
      // and potentially combining these temp files or using the last one. This is inefficient.

      if (_allClassNames.isNotEmpty) {
        final generatedCssMap = generateAtomicCss(_allClassNames);
        if (generatedCssMap.isNotEmpty) {
          final cssBuffer = StringBuffer();
          cssBuffer.writeln('/* Generated by Dust AtomicStyleBuilder */');
          // Sort class names for consistent output
          final sortedClassNames = generatedCssMap.keys.toList()..sort();
          for (final className in sortedClassNames) {
            // Escape class name for CSS selector
            final escapedClassName = className.replaceAllMapped(
                RegExp(r'[.:/\]'), (match) => '\\${match.group(0)}');
            cssBuffer.writeln('.$escapedClassName {');
            cssBuffer.writeln('  ${generatedCssMap[className]}');
            cssBuffer.writeln('}');
          }

          // Write to a temporary output associated with the input Dart file
          final tempOutputId =
              inputId.changeExtension('.atomic_styles.css.temp');
          await buildStep.writeAsString(tempOutputId, cssBuffer.toString());
          print(
              "AtomicStyleBuilder: Wrote cumulative CSS to ${tempOutputId.path} (${_allClassNames.length} classes total)");
        }
      }
    } catch (e, s) {
      log.severe('Error processing ${inputId.path}: $e\n$s');
    }
  }
}

// AST Visitor to find 'class' attributes within HTML helper function calls
class _ClassNameVisitor extends RecursiveAstVisitor<void> {
  final Set<String> foundClassNames = {};

  // TODO: Make this list configurable or more robust
  final Set<String> htmlHelperFunctionNames = {
    'div', 'span', 'p', 'h1', 'h2', 'h3', 'ul', 'li', 'button', 'input',
    // Add other helper function names here
  };

  @override
  void visitMethodInvocation(MethodInvocation node) {
    super.visitMethodInvocation(node); // Visit children first

    final functionName = node.methodName.name;

    // Check if it's one of our HTML helper functions
    if (htmlHelperFunctionNames.contains(functionName)) {
      // Find the 'attributes' named argument by iterating
      NamedExpression? attributesArg;
      for (final arg in node.argumentList.arguments) {
        if (arg is NamedExpression && arg.name.label.name == 'attributes') {
          attributesArg = arg;
          break;
        }
      }

      // Check if attributesArg was found and is a map literal
      if (attributesArg != null &&
          attributesArg.expression is SetOrMapLiteral) {
        final mapLiteral = attributesArg.expression as SetOrMapLiteral;
        // Find the 'class' entry within the map literal
        for (final element in mapLiteral.elements) {
          if (element is MapLiteralEntry) {
            final key = element.key;
            final value = element.value;
            // Check if the key is a string literal 'class'
            if (key is SimpleStringLiteral &&
                key.value == 'class' &&
                value is SimpleStringLiteral) {
              // Extract class names from the string value
              final classString = value.value;
              final classes = classString.split(' ').where((c) => c.isNotEmpty);
              foundClassNames.addAll(classes);
              print(
                  "AtomicStyleBuilder Visitor: Found classes: $classes in ${node.methodName}");
            }
          }
        }
      }
    }
  }
}
